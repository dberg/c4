The Server is responsible to maintain connections with c4 clients and to manage the data flow, using a Message instance, between the client and the projects that are active on the server at any point in time.

When the Server starts it triggers the following actions:

  - Create listening socket
  - Initialize kqueue*
  - Initialize kevent arrays
  - Setup kevent structure with listening socket
  - loop && kevent syscall
    - case error
    - case listening socket
    - case socket has data to be read
      - read data and send it to Project

* BSD specific. We'll have something similar for Linux using epoll.

--------------------------------------------------------------------------------

Questions:

  1. how multiplexed writes work? Also, if we have more data than the kernel buffer can receive we should keep the remaining bytes to be sent until kernel buffer has space for it.

  2. If the connection is broken, how are we notified so we can remove the mapping between the socket and Project instance?

--------------------------------------------------------------------------------

When the Server is reading data, it buffers all incoming bytes in a MessageBuffer until it has a complete Message object. On the other end, when asked to send a Message to the client, the Server will transform the Message into a MessageBuffer and hold it until the complete Message is sent to the client or a connection problem is found.

After the Server has read a complete Message, it sends the Message to the ProjectHandler instance, which in turn, will match the Message to the correct Project instance, and pass the Message to the Project to process it.

  Server -> ProjectHandler -> Project

The ProjectHandler, upon receiving a complete Message and matching it to a Project instance, takes a thread out of a thread pool, and asks the Project instance to process the Message. For example, a Message can be a request to process a compilation unit. The result of processing the compilation is a different type of Message which is contains a response to the Client. The flow is then inverted:

  Project -> ProjectHandler -> Server


