(eval-and-compile
  (require 'cc-mode))     ; (only) for `c-populate-syntax-table'

;; TODO: remove hardcoded paths
(defvar djp-executable "~/dev/djp/src/out/Debug/bin/djp")
(defvar djp-tmp-buffer "/tmp/djp-mode-buffer")

;; Indentation
(defvar djp-indentation-char ?\s)
(defvar djp-indentation-count 4)
(defvar djp-indentation-linewrap 8)

;; Font faces
(setq djp-sh-face-table #s(hash-table test eq data
  (djp-sh-annotation-tok-at nil
   djp-sh-comment font-lock-comment-face
   djp-sh-identifier nil
   djp-sh-keyword font-lock-keyword-face
   djp-sh-literal-char nil
   djp-sh-literal-number nil
   djp-sh-op nil
   djp-sh-reference-type-id font-lock-type-face
   djp-sh-string-literal font-lock-string-face)))

;; Errors font face
(defface djp-error-face
  `((((class color) (background light))
     (:underline  "orange"))
    (((class color) (background dark))
     (:underline "orange"))
    (t (:underline t)))
  "Face for Java errors."
  :group 'djp-mode)

;; timer
(defvar djp-mode-parser-timer nil)

(defvar djp-idle-timer-delay 0.2
  "Delay in seconds before re-parsing after user makes changes.")

(defvar djp-mode-parsing nil)

(defvar djp-syntax-highlighting []
  "The array output generated by the parser.")

(defvar djp-errors []
  "The array output generated by the parser.")

(defvar djp-symbol-table []
  "The symbol table generated by the parser.")

(defvar djp-indentation-table nil
  "The indentation hash table generated by the parser.")

(defun djp-reset-parser ()
  (setq djp-syntax-highlighting nil))

;; indentation
(defun djp-indent-line ()
  (let* ((line (line-number-at-pos))
         (indent (gethash (- line 1) djp-indentation-table))
         (indent-value 0)
         ini end indent-str)
    (if indent
        (save-excursion
          (beginning-of-line)
          (setq ini (point))
          (skip-chars-forward " \t")
          (setq end (point))
          (setq indent-value
                (+ (* (car indent) djp-indentation-count)
                   (* (cadr indent) djp-indentation-linewrap)
                   (car (cddr indent))))
          (setq indent-str (make-string indent-value djp-indentation-char))
          (if (not (string= (buffer-substring-no-properties ini end) indent-str))
              (progn
                (delete-horizontal-space)
                (insert indent-str)))))))


;; djp-mode
(defvar djp-mode-syntax-table
  (let ((table (make-syntax-table)))
    (c-populate-syntax-table table)
    table)
  "Syntax table used in djp-mode buffers.")

(defvar djp-mode-map
  (let ((map (make-sparse-keymap))
        keys)
    ;(define-key map (kbd "C-m") #'djp-enter-key)
    ;(define-key map (kbd "C-a") #'djp-beginning-of-line)
    map)
  "Keymap used in `djp-mode' buffers.")

(defvar djp-mode-abbrev-table nil
  "Abbrev table in use in `djp-mode' buffers.")
(define-abbrev-table 'djp-mode-abbrev-table ())

;;;###autoload
(defun djp-mode ()
  "Major mode for Java"
  (interactive)
  (kill-all-local-variables)
  (set-syntax-table djp-mode-syntax-table)
  (use-local-map djp-mode-map)
  (setq major-mode 'djp-mode
        mode-name "DJP"
        comment-start "//"
        comment-end "")
  (setq local-abbrev-table djp-mode-abbrev-table)
  (set (make-local-variable 'indent-line-function) #'djp-indent-line)
  (set (make-local-variable 'indent-region-function) nil)

  ;; We do our own syntax highlighting based on the parse tree.
  ;; However, we want minor modes that add keywords to highlight properly
  ;; We do this by not letting font-lock unfontify anything, and telling it to
  ;; fontify after we re-parse and re-highlight the buffer.  (We currently don't
  ;; do any work with regions other than the whole buffer.)
  (dolist (var '(font-lock-unfontify-buffer-function
                 font-lock-unfontify-region-function))
    (set (make-local-variable var) (lambda (&rest args) t)))

  ;; Don't let font-lock do syntactic (string/comment) fontification.
  (set (make-local-variable #'font-lock-syntactic-face-function)
       (lambda (state) nil))

  (add-hook 'after-change-functions #'djp-mode-edit nil t)

  (djp-reparse))

(defun djp-mode-reset-timer ()
  (if djp-mode-parser-timer
      (cancel-timer djp-mode-parser-timer))
  (setq djp-mode-parsing nil)
  (setq djp-mode-parser-timer
        (run-with-idle-timer djp-idle-timer-delay nil #'djp-reparse)))

(defun djp-mode-edit (beg end len)
  "Schedule a new parse after buffer is edited."
  (djp-mode-reset-timer))

(defun djp-reparse ()
  (let (interrupted-p)
    (unless djp-mode-parsing
      (setq djp-mode-parsing t)
      (djp-reset-parser)
      (unwind-protect
          (progn
            (djp-with-unmodifying-text-property-changes
              (remove-text-properties (point-min) (point-max) '(syntax-table))
              (remove-text-properties (point-min) (point-max) '(face nil))
              (djp-remove-overlays)
              (djp-clear-face (point-min) (point-max))
              (setq interrupted-p
                    (catch 'interrupted
                      (djp-parse)
                      (djp-do-syntax-highlight)
                      (djp-process-errors)
                      nil))
              (if interrupted-p
                  (djp-mode-reset-timer))
              (setq djp-mode-parsing nil)
              (unless interrupted-p
                (setq djp-mode-parse-timer nil))))))))

(defun djp-parse ()
  "We save the buffer content into a temporary file and trigger the compiler.
The output of the compiler is used to build djp-syntax-highlighting,
djp-errors, djp-symbol-table and djp-indentation-table."
  (let (cmd compiler-output tmp)
    (write-region (point-min) (point-max) djp-tmp-buffer)
    (setq cmd (concat djp-executable " -i java -f " djp-tmp-buffer))
    (setq compiler-output (shell-command-to-string cmd))
    ;; 1. array with syntax highlighting info
    (setq tmp (read-from-string compiler-output))
    (setq djp-syntax-highlighting (car tmp))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 2. array with error info
    (setq djp-errors (eval (car tmp)))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 3. array with symbol table
    (setq djp-symbol-table (eval (car tmp)))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 4. hash-table with indentation info
    (setq djp-indentation-table (eval (car tmp)))))

(defun djp-do-syntax-highlight ()
  "Iterate djp-syntax-highlighting applying font-lock face for each node)"
  (let (face)
    (mapc (lambda (item)
            (setq face (gethash (car item) djp-sh-face-table))
            (if face
                (put-text-property
                 (car (cdr item))  ; ini
                 (car (cddr item)) ; end
                 'face face)))
          djp-syntax-highlighting)))

(defun djp-process-errors ()
  (mapc (lambda (err-info)
          (djp-process-error
           (car err-info)               ; ini
           (car (cdr err-info))         ; end
           (car (cdr (cdr err-info))))) ; msg
        djp-errors))

(defun djp-process-error (ini end msg)
  (let ((ovl (make-overlay ini end)))
    ;; Add identifier so we can delete this overlay when reparsing
    (overlay-put ovl 'djp-error t)
    (overlay-put ovl 'face 'djp-error-face)
    (put-text-property ini end 'help-echo msg)
    (put-text-property ini end 'point-entered #'djp-echo-error)))

(defun djp-echo-error (old-point new-point)
  "Called by point-motion hooks."
  (let ((msg (get-text-property new-point 'help-echo)))
    (if msg
        (message msg))))

(defun djp-clear-face (beg end)
  (remove-text-properties beg end '(face nil
                                    help-echo nil
                                    point-entered nil)))

(defun djp-remove-overlays ()
  "Remove overlays from buffer that have a `djp-error' property."
  (let ((beg (point-min))
        (end (point-max)))
    (save-excursion
      (dolist (o (overlays-in beg end))
        (when (overlay-get o 'djp-error)
          (delete-overlay o))))))

;; Stolen from js2-mode where you can read:
;; `Stolen shamelessly from James Clark's nxml-mode.'
(defmacro djp-with-unmodifying-text-property-changes (&rest body)
  "Evaluate BODY without any text property changes modifying the buffer.
Any text properties changes happen as usual but the changes are not treated as
modifications to the buffer."
  (declare (indent 0) (debug t))
  (let ((modified (make-symbol "modified")))
    `(let ((,modified (buffer-modified-p))
           (inhibit-read-only t)
           (inhibit-modification-hooks t)
           (buffer-undo-list t)
           (deactivate-mark nil)
           ;; Apparently these avoid file locking problems.
           (buffer-file-name nil)
           (buffer-file-truename nil))
       (unwind-protect
           (progn ,@body)
         (unless ,modified
           (restore-buffer-modified-p nil))))))

(provide 'djp-mode)

;;; djp-mode.el ends here
