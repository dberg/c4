;; Indentation
(defvar c4j-indentation-char ?\s)
(defvar c4j-indentation-count 4)
(defvar c4j-indentation-linewrap 8)

;; Font faces
(setq c4j-sh-face-table #s(hash-table test eq data
  (c4j-sh-annotation-tok-at nil
   c4j-sh-comment font-lock-comment-face
   c4j-sh-identifier nil
   c4j-sh-keyword font-lock-keyword-face
   c4j-sh-literal-char nil
   c4j-sh-literal-number nil
   c4j-sh-op nil
   c4j-sh-reference-type-id font-lock-type-face
   c4j-sh-string-literal font-lock-string-face)))

;; Errors font face
(defface c4j-error-face
  `((((class color) (background light))
     (:underline  "orange"))
    (((class color) (background dark))
     (:underline "orange"))
    (t (:underline t)))
  "Face for Java errors."
  :group 'c4j-mode)

;; timer
(defvar c4j-mode-parser-timer nil)

(defvar c4j-idle-timer-delay 0.2
  "Delay in seconds before re-parsing after user makes changes.")

(defvar c4j-mode-parsing nil)

(defvar c4j-syntax-highlighting []
  "The array output generated by the parser.")

(defvar c4j-errors []
  "The array output generated by the parser.")

(defvar c4j-symbol-table []
  "The symbol table generated by the parser.")

(defvar c4j-indentation-table nil
  "The indentation hash table generated by the parser.")

(defun c4j-reset-parser ()
  (setq c4j-syntax-highlighting nil))

;; indentation
(defun c4j-indent-line ()
  (let* ((line (line-number-at-pos))
         (indent (gethash (- line 1) c4j-indentation-table))
         (indent-value 0)
         ini end indent-str)
    (if indent
        (save-excursion
          (beginning-of-line)
          (setq ini (point))
          (skip-chars-forward " \t")
          (setq end (point))
          (setq indent-value
                (+ (* (car indent) c4j-indentation-count)
                   (* (cadr indent) c4j-indentation-linewrap)
                   (car (cddr indent))))
          (setq indent-str (make-string indent-value c4j-indentation-char))
          (if (not (string= (buffer-substring-no-properties ini end) indent-str))
              (progn
                (delete-horizontal-space)
                (insert indent-str)))))))

(defun c4j-mode ()
  "Major mode for Java"
  (interactive)
  (kill-all-local-variables)
  (set-syntax-table c4j-mode-syntax-table)
  (use-local-map c4j-mode-map)
  (setq major-mode 'c4j-mode
        mode-name "c4-java"
        comment-start "//"
        comment-end "")
  (setq local-abbrev-table c4j-mode-abbrev-table)
  (set (make-local-variable 'indent-line-function) #'c4j-indent-line)
  (set (make-local-variable 'indent-region-function) nil)

  ;; We do our own syntax highlighting based on the parse tree.
  ;; However, we want minor modes that add keywords to highlight properly
  ;; We do this by not letting font-lock unfontify anything, and telling it to
  ;; fontify after we re-parse and re-highlight the buffer.  (We currently don't
  ;; do any work with regions other than the whole buffer.)
  (dolist (var '(font-lock-unfontify-buffer-function
                 font-lock-unfontify-region-function))
    (set (make-local-variable var) (lambda (&rest args) t)))

  ;; Don't let font-lock do syntactic (string/comment) fontification.
  (set (make-local-variable #'font-lock-syntactic-face-function)
       (lambda (state) nil))

  (add-hook 'after-change-functions #'c4j-mode-edit nil t)

  (c4j-reparse))

;; c4j-mode
(defvar c4j-mode-syntax-table
  (let ((table (make-syntax-table)))
    (c-populate-syntax-table table)
    table)
  "Syntax table used in c4j-mode buffers.")

(defvar c4j-mode-map
  (let ((map (make-sparse-keymap))
        keys)
    ;(define-key map (kbd "C-m") #'c4j-enter-key)
    ;(define-key map (kbd "C-a") #'c4j-beginning-of-line)
    map)
  "Keymap used in `c4j-mode' buffers.")

(defvar c4j-mode-abbrev-table nil
  "Abbrev table in use in `c4j-mode' buffers.")
(define-abbrev-table 'c4j-mode-abbrev-table ())

(defun c4j-mode-reset-timer ()
  (if c4j-mode-parser-timer
      (cancel-timer c4j-mode-parser-timer))
  (setq c4j-mode-parsing nil)
  (setq c4j-mode-parser-timer
        (run-with-idle-timer c4j-idle-timer-delay nil #'c4j-reparse)))

(defun c4j-mode-edit (beg end len)
  "Schedule a new parse after buffer is edited."
  (c4j-mode-reset-timer))

(defun c4j-reparse ()
  (let (interrupted-p)
    (unless c4j-mode-parsing
      (setq c4j-mode-parsing t)
      (c4j-reset-parser)
      (unwind-protect
          (progn
            (c4j-with-unmodifying-text-property-changes
              (remove-text-properties (point-min) (point-max) '(syntax-table))
              (remove-text-properties (point-min) (point-max) '(face nil))
              (c4j-remove-overlays)
              (c4j-clear-face (point-min) (point-max))
              (setq interrupted-p
                    (catch 'interrupted
                      (c4j-parse)
                      (c4j-do-syntax-highlight)
                      (c4j-process-errors)
                      nil))
              (if interrupted-p
                  (c4j-mode-reset-timer))
              (setq c4j-mode-parsing nil)
              (unless interrupted-p
                (setq c4j-mode-parse-timer nil))))))))

(defun c4j-parse ()
  "We save the buffer content into a temporary file and trigger the compiler.
The output of the compiler is used to build c4j-syntax-highlighting,
c4j-errors, c4j-symbol-table and c4j-indentation-table."
  (let (cmd compiler-output tmp)
    (write-region (point-min) (point-max) c4-tmp-buffer)
    (setq cmd (concat c4-executable " -i java -f " c4-tmp-buffer))
    (setq compiler-output (shell-command-to-string cmd))
    ;; 1. array with syntax highlighting info
    (setq tmp (read-from-string compiler-output))
    (setq c4j-syntax-highlighting (car tmp))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 2. array with error info
    (setq c4j-errors (eval (car tmp)))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 3. array with symbol table
    (setq c4j-symbol-table (eval (car tmp)))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 4. hash-table with indentation info
    (setq c4j-indentation-table (eval (car tmp)))))

(defun c4j-do-syntax-highlight ()
  "Iterate c4j-syntax-highlighting applying font-lock face for each node)"
  (let (face)
    (mapc (lambda (item)
            (setq face (gethash (car item) c4j-sh-face-table))
            (if face
                (put-text-property
                 (car (cdr item))  ; ini
                 (car (cddr item)) ; end
                 'face face)))
          c4j-syntax-highlighting)))

(defun c4j-process-errors ()
  (mapc (lambda (err-info)
          (c4j-process-error
           (car err-info)               ; ini
           (car (cdr err-info))         ; end
           (car (cdr (cdr err-info))))) ; msg
        c4j-errors))

(defun c4j-process-error (ini end msg)
  (let ((ovl (make-overlay ini end)))
    ;; Add identifier so we can delete this overlay when reparsing
    (overlay-put ovl 'c4j-error t)
    (overlay-put ovl 'face 'c4j-error-face)
    (put-text-property ini end 'help-echo msg)
    (put-text-property ini end 'point-entered #'c4j-echo-error)))

(defun c4j-echo-error (old-point new-point)
  "Called by point-motion hooks."
  (let ((msg (get-text-property new-point 'help-echo)))
    (if msg
        (message msg))))

(defun c4j-clear-face (beg end)
  (remove-text-properties beg end '(face nil
                                    help-echo nil
                                    point-entered nil)))

(defun c4j-remove-overlays ()
  "Remove overlays from buffer that have a `c4j-error' property."
  (let ((beg (point-min))
        (end (point-max)))
    (save-excursion
      (dolist (o (overlays-in beg end))
        (when (overlay-get o 'c4j-error)
          (delete-overlay o))))))

;; Stolen from js2-mode where you can read:
;; `Stolen shamelessly from James Clark's nxml-mode.'
(defmacro c4j-with-unmodifying-text-property-changes (&rest body)
  "Evaluate BODY without any text property changes modifying the buffer.
Any text properties changes happen as usual but the changes are not treated as
modifications to the buffer."
  (declare (indent 0) (debug t))
  (let ((modified (make-symbol "modified")))
    `(let ((,modified (buffer-modified-p))
           (inhibit-read-only t)
           (inhibit-modification-hooks t)
           (buffer-undo-list t)
           (deactivate-mark nil)
           ;; Apparently these avoid file locking problems.
           (buffer-file-name nil)
           (buffer-file-truename nil))
       (unwind-protect
           (progn ,@body)
         (unless ,modified
           (restore-buffer-modified-p nil))))))

(provide 'c4j)
