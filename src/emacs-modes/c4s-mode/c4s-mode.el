(eval-and-compile
  (require 'cc-mode))     ; (only) for `c-populate-syntax-table'

;; TODO: remove hardcoded paths
(defvar c4s-executable "~/dev/c4/src/out/Debug/bin/c4")
(defvar c4s-tmp-buffer "/tmp/c4s-mode-buffer")

;; Indentation
(defvar c4s-indentation-char ?\s)
(defvar c4s-indentation-count 2)
(defvar c4s-indentation-linewrap 4)

;; Font faces
(setq c4s-sh-face-table #s(hash-table test eq data
  (c4s-sh-annotation-tok-at nil
   c4s-sh-comment font-lock-comment-face
   c4s-sh-identifier nil
   c4s-sh-keyword font-lock-keyword-face
   c4s-sh-literal-char nil
   c4s-sh-literal-number nil
   c4s-sh-op nil
   c4s-sh-reference-type-id font-lock-type-face
   c4s-sh-string-literal font-lock-string-face)))

;; Errors font face
(defface c4s-error-face
  `((((class color) (background light))
     (:underline  "orange"))
    (((class color) (background dark))
     (:underline "orange"))
    (t (:underline t)))
  "Face for Scala errors."
  :group 'c4s-mode)

;; timer
(defvar c4s-mode-parser-timer nil)

(defvar c4s-idle-timer-delay 0.2
  "Delay in seconds before re-parsing after user makes changes.")

(defvar c4s-mode-parsing nil)

(defvar c4s-syntax-highlighting []
  "The array output generated by the parser.")

(defvar c4s-errors []
  "The array output generated by the parser.")

(defvar c4s-symbol-table []
  "The symbol table generated by the parser.")

(defvar c4s-indentation-table nil
  "The indentation hash table generated by the parser.")

(defun c4s-reset-parser ()
  (setq c4s-syntax-highlighting nil))

;; indentation
(defun c4s-indent-line ()
  (let* ((line (line-number-at-pos))
         (indent (gethash (- line 1) c4s-indentation-table))
         (indent-value 0)
         ini end indent-str)
    (if indent
        (save-excursion
          (beginning-of-line)
          (setq ini (point))
          (skip-chars-forward " \t")
          (setq end (point))
          (setq indent-value
                (+ (* (car indent) c4s-indentation-count)
                   (* (cadr indent) c4s-indentation-linewrap)
                   (car (cddr indent))))
          (setq indent-str (make-string indent-value c4s-indentation-char))
          (if (not (string= (buffer-substring-no-properties ini end) indent-str))
              (progn
                (delete-horizontal-space)
                (insert indent-str)))))))


;; c4s-mode
(defvar c4s-mode-syntax-table
  (let ((table (make-syntax-table)))
    (c-populate-syntax-table table)
    table)
  "Syntax table used in c4s-mode buffers.")

(defvar c4s-mode-map
  (let ((map (make-sparse-keymap))
        keys)
    ;(define-key map (kbd "C-m") #'c4s-enter-key)
    ;(define-key map (kbd "C-a") #'c4s-beginning-of-line)
    map)
  "Keymap used in `c4s-mode' buffers.")

(defvar c4s-mode-abbrev-table nil
  "Abbrev table in use in `c4s-mode' buffers.")
(define-abbrev-table 'c4s-mode-abbrev-table ())

;;;###autoload
(defun c4s-mode ()
  "Major mode for Scala"
  (interactive)
  (kill-all-local-variables)
  (set-syntax-table c4s-mode-syntax-table)
  (use-local-map c4s-mode-map)
  (setq major-mode 'c4s-mode
        mode-name "c4s"
        comment-start "//"
        comment-end "")
  (setq local-abbrev-table c4s-mode-abbrev-table)
  (set (make-local-variable 'indent-line-function) #'c4s-indent-line)
  (set (make-local-variable 'indent-region-function) nil)

  ;; We do our own syntax highlighting based on the parse tree.
  ;; However, we want minor modes that add keywords to highlight properly
  ;; We do this by not letting font-lock unfontify anything, and telling it to
  ;; fontify after we re-parse and re-highlight the buffer.  (We currently don't
  ;; do any work with regions other than the whole buffer.)
  (dolist (var '(font-lock-unfontify-buffer-function
                 font-lock-unfontify-region-function))
    (set (make-local-variable var) (lambda (&rest args) t)))

  ;; Don't let font-lock do syntactic (string/comment) fontification.
  (set (make-local-variable #'font-lock-syntactic-face-function)
       (lambda (state) nil))

  (add-hook 'after-change-functions #'c4s-mode-edit nil t)

  (c4s-reparse))

(defun c4s-mode-reset-timer ()
  (if c4s-mode-parser-timer
      (cancel-timer c4s-mode-parser-timer))
  (setq c4s-mode-parsing nil)
  (setq c4s-mode-parser-timer
        (run-with-idle-timer c4s-idle-timer-delay nil #'c4s-reparse)))

(defun c4s-mode-edit (beg end len)
  "Schedule a new parse after buffer is edited."
  (c4s-mode-reset-timer))

(defun c4s-reparse ()
  (let (interrupted-p)
    (unless c4s-mode-parsing
      (setq c4s-mode-parsing t)
      (c4s-reset-parser)
      (unwind-protect
          (progn
            (c4s-with-unmodifying-text-property-changes
              (remove-text-properties (point-min) (point-max) '(syntax-table))
              (remove-text-properties (point-min) (point-max) '(face nil))
              (c4s-remove-overlays)
              (c4s-clear-face (point-min) (point-max))
              (setq interrupted-p
                    (catch 'interrupted
                      (c4s-parse)
                      (c4s-do-syntax-highlight)
                      (c4s-process-errors)
                      nil))
              (if interrupted-p
                  (c4s-mode-reset-timer))
              (setq c4s-mode-parsing nil)
              (unless interrupted-p
                (setq c4s-mode-parse-timer nil))))))))

(defun c4s-parse ()
  "We save the buffer content into a temporary file and trigger the compiler.
The output of the compiler is used to build c4s-syntax-highlighting,
c4s-errors, c4s-symbol-table and c4s-indentation-table."
  (let (cmd compiler-output tmp)
    (write-region (point-min) (point-max) c4s-tmp-buffer)
    (setq cmd (concat c4s-executable " -i scala -f " c4s-tmp-buffer))
    (setq compiler-output (shell-command-to-string cmd))
    ;; 1. array with syntax highlighting info
    (setq tmp (read-from-string compiler-output))
    (setq c4s-syntax-highlighting (car tmp))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 2. array with error info
    (setq c4s-errors (eval (car tmp)))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 3. hash-table with indentation info
    (setq c4s-indentation-table (eval (car tmp)))))

(defun c4s-do-syntax-highlight ()
  "Iterate c4s-syntax-highlighting applying font-lock face for each node)"
  (let (face)
    (mapc (lambda (item)
            (setq face (gethash (car item) c4s-sh-face-table))
            (if face
                (put-text-property
                 (car (cdr item))  ; ini
                 (car (cddr item)) ; end
                 'face face)))
          c4s-syntax-highlighting)))

(defun c4s-process-errors ()
  (mapc (lambda (err-info)
          (c4s-process-error
           (car err-info)               ; ini
           (car (cdr err-info))         ; end
           (car (cdr (cdr err-info))))) ; msg
        c4s-errors))

(defun c4s-process-error (ini end msg)
  (let ((ovl (make-overlay ini end)))
    ;; Add identifier so we can delete this overlay when reparsing
    (overlay-put ovl 'c4s-error t)
    (overlay-put ovl 'face 'c4s-error-face)
    (put-text-property ini end 'help-echo msg)
    (put-text-property ini end 'point-entered #'c4s-echo-error)))

(defun c4s-echo-error (old-point new-point)
  "Called by point-motion hooks."
  (let ((msg (get-text-property new-point 'help-echo)))
    (if msg
        (message msg))))

(defun c4s-clear-face (beg end)
  (remove-text-properties beg end '(face nil
                                    help-echo nil
                                    point-entered nil)))

(defun c4s-remove-overlays ()
  "Remove overlays from buffer that have a `c4s-error' property."
  (let ((beg (point-min))
        (end (point-max)))
    (save-excursion
      (dolist (o (overlays-in beg end))
        (when (overlay-get o 'c4s-error)
          (delete-overlay o))))))

;; Stolen from js2-mode where you can read:
;; `Stolen shamelessly from James Clark's nxml-mode.'
(defmacro c4s-with-unmodifying-text-property-changes (&rest body)
  "Evaluate BODY without any text property changes modifying the buffer.
Any text properties changes happen as usual but the changes are not treated as
modifications to the buffer."
  (declare (indent 0) (debug t))
  (let ((modified (make-symbol "modified")))
    `(let ((,modified (buffer-modified-p))
           (inhibit-read-only t)
           (inhibit-modification-hooks t)
           (buffer-undo-list t)
           (deactivate-mark nil)
           ;; Apparently these avoid file locking problems.
           (buffer-file-name nil)
           (buffer-file-truename nil))
       (unwind-protect
           (progn ,@body)
         (unless ,modified
           (restore-buffer-modified-p nil))))))

(provide 'c4s-mode)

;;; c4s-mode.el ends here
