(eval-and-compile
  (require 'cc-mode))     ; (only) for `c-populate-syntax-table'

;; TODO: remove hardcoded paths
(defvar dsp-executable "~/dev/djp/src/out/Debug/bin/djp")
(defvar dsp-tmp-buffer "/tmp/dsp-mode-buffer")

;; Indentation
(defvar dsp-indentation-char ?\s)
(defvar dsp-indentation-count 2)
(defvar dsp-indentation-linewrap 4)

;; Font faces
(setq dsp-sh-face-table #s(hash-table test eq data
  (dsp-sh-annotation-tok-at nil
   dsp-sh-comment font-lock-comment-face
   dsp-sh-identifier nil
   dsp-sh-keyword font-lock-keyword-face
   dsp-sh-literal-char nil
   dsp-sh-literal-number nil
   dsp-sh-op nil
   dsp-sh-reference-type-id font-lock-type-face
   dsp-sh-string-literal font-lock-string-face)))

;; Errors font face
(defface dsp-error-face
  `((((class color) (background light))
     (:underline  "orange"))
    (((class color) (background dark))
     (:underline "orange"))
    (t (:underline t)))
  "Face for Scala errors."
  :group 'dsp-mode)

;; timer
(defvar dsp-mode-parser-timer nil)

(defvar dsp-idle-timer-delay 0.2
  "Delay in seconds before re-parsing after user makes changes.")

(defvar dsp-mode-parsing nil)

(defvar dsp-syntax-highlighting []
  "The array output generated by the parser.")

(defvar dsp-errors []
  "The array output generated by the parser.")

(defvar dsp-symbol-table []
  "The symbol table generated by the parser.")

(defvar dsp-indentation-table nil
  "The indentation hash table generated by the parser.")

(defun dsp-reset-parser ()
  (setq dsp-syntax-highlighting nil))

;; indentation
(defun dsp-indent-line ()
  (let* ((line (line-number-at-pos))
         (indent (gethash (- line 1) dsp-indentation-table))
         (indent-value 0)
         ini end indent-str)
    (if indent
        (save-excursion
          (beginning-of-line)
          (setq ini (point))
          (skip-chars-forward " \t")
          (setq end (point))
          (setq indent-value
                (+ (* (car indent) dsp-indentation-count)
                   (* (cadr indent) dsp-indentation-linewrap)
                   (car (cddr indent))))
          (setq indent-str (make-string indent-value dsp-indentation-char))
          (if (not (string= (buffer-substring-no-properties ini end) indent-str))
              (progn
                (delete-horizontal-space)
                (insert indent-str)))))))


;; dsp-mode
(defvar dsp-mode-syntax-table
  (let ((table (make-syntax-table)))
    (c-populate-syntax-table table)
    table)
  "Syntax table used in dsp-mode buffers.")

(defvar dsp-mode-map
  (let ((map (make-sparse-keymap))
        keys)
    ;(define-key map (kbd "C-m") #'dsp-enter-key)
    ;(define-key map (kbd "C-a") #'dsp-beginning-of-line)
    map)
  "Keymap used in `dsp-mode' buffers.")

(defvar dsp-mode-abbrev-table nil
  "Abbrev table in use in `dsp-mode' buffers.")
(define-abbrev-table 'dsp-mode-abbrev-table ())

;;;###autoload
(defun dsp-mode ()
  "Major mode for Scala"
  (interactive)
  (kill-all-local-variables)
  (set-syntax-table dsp-mode-syntax-table)
  (use-local-map dsp-mode-map)
  (setq major-mode 'dsp-mode
        mode-name "DSP"
        comment-start "//"
        comment-end "")
  (setq local-abbrev-table dsp-mode-abbrev-table)
  (set (make-local-variable 'indent-line-function) #'dsp-indent-line)
  (set (make-local-variable 'indent-region-function) nil)

  ;; We do our own syntax highlighting based on the parse tree.
  ;; However, we want minor modes that add keywords to highlight properly
  ;; We do this by not letting font-lock unfontify anything, and telling it to
  ;; fontify after we re-parse and re-highlight the buffer.  (We currently don't
  ;; do any work with regions other than the whole buffer.)
  (dolist (var '(font-lock-unfontify-buffer-function
                 font-lock-unfontify-region-function))
    (set (make-local-variable var) (lambda (&rest args) t)))

  ;; Don't let font-lock do syntactic (string/comment) fontification.
  (set (make-local-variable #'font-lock-syntactic-face-function)
       (lambda (state) nil))

  (add-hook 'after-change-functions #'dsp-mode-edit nil t)

  (dsp-reparse))

(defun dsp-mode-reset-timer ()
  (if dsp-mode-parser-timer
      (cancel-timer dsp-mode-parser-timer))
  (setq dsp-mode-parsing nil)
  (setq dsp-mode-parser-timer
        (run-with-idle-timer dsp-idle-timer-delay nil #'dsp-reparse)))

(defun dsp-mode-edit (beg end len)
  "Schedule a new parse after buffer is edited."
  (dsp-mode-reset-timer))

(defun dsp-reparse ()
  (let (interrupted-p)
    (unless dsp-mode-parsing
      (setq dsp-mode-parsing t)
      (dsp-reset-parser)
      (unwind-protect
          (progn
            (dsp-with-unmodifying-text-property-changes
              (remove-text-properties (point-min) (point-max) '(syntax-table))
              (remove-text-properties (point-min) (point-max) '(face nil))
              (dsp-remove-overlays)
              (dsp-clear-face (point-min) (point-max))
              (setq interrupted-p
                    (catch 'interrupted
                      (dsp-parse)
                      (dsp-do-syntax-highlight)
                      (dsp-process-errors)
                      nil))
              (if interrupted-p
                  (dsp-mode-reset-timer))
              (setq dsp-mode-parsing nil)
              (unless interrupted-p
                (setq dsp-mode-parse-timer nil))))))))

(defun dsp-parse ()
  "We save the buffer content into a temporary file and trigger the compiler.
The output of the compiler is used to build dsp-syntax-highlighting,
dsp-errors, dsp-symbol-table and dsp-indentation-table."
  (let (cmd compiler-output tmp)
    (write-region (point-min) (point-max) dsp-tmp-buffer)
    (setq cmd (concat dsp-executable " -i scala -f " dsp-tmp-buffer))
    (setq compiler-output (shell-command-to-string cmd))
    ;; 1. array with syntax highlighting info
    (setq tmp (read-from-string compiler-output))
    (setq dsp-syntax-highlighting (car tmp))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 2. array with error info
    (setq dsp-errors (eval (car tmp)))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 3. array with symbol table
    (setq dsp-symbol-table (eval (car tmp)))
    (setq tmp (read-from-string compiler-output (cdr tmp)))
    ;; 4. hash-table with indentation info
    (setq dsp-indentation-table (eval (car tmp)))))

(defun dsp-do-syntax-highlight ()
  "Iterate dsp-syntax-highlighting applying font-lock face for each node)"
  (let (face)
    (mapc (lambda (item)
            (setq face (gethash (car item) dsp-sh-face-table))
            (if face
                (put-text-property
                 (car (cdr item))  ; ini
                 (car (cddr item)) ; end
                 'face face)))
          dsp-syntax-highlighting)))

(defun dsp-process-errors ()
  (mapc (lambda (err-info)
          (dsp-process-error
           (car err-info)               ; ini
           (car (cdr err-info))         ; end
           (car (cdr (cdr err-info))))) ; msg
        dsp-errors))

(defun dsp-process-error (ini end msg)
  (let ((ovl (make-overlay ini end)))
    ;; Add identifier so we can delete this overlay when reparsing
    (overlay-put ovl 'dsp-error t)
    (overlay-put ovl 'face 'dsp-error-face)
    (put-text-property ini end 'help-echo msg)
    (put-text-property ini end 'point-entered #'dsp-echo-error)))

(defun dsp-echo-error (old-point new-point)
  "Called by point-motion hooks."
  (let ((msg (get-text-property new-point 'help-echo)))
    (if msg
        (message msg))))

(defun dsp-clear-face (beg end)
  (remove-text-properties beg end '(face nil
                                    help-echo nil
                                    point-entered nil)))

(defun dsp-remove-overlays ()
  "Remove overlays from buffer that have a `dsp-error' property."
  (let ((beg (point-min))
        (end (point-max)))
    (save-excursion
      (dolist (o (overlays-in beg end))
        (when (overlay-get o 'dsp-error)
          (delete-overlay o))))))

;; Stolen from js2-mode where you can read:
;; `Stolen shamelessly from James Clark's nxml-mode.'
(defmacro dsp-with-unmodifying-text-property-changes (&rest body)
  "Evaluate BODY without any text property changes modifying the buffer.
Any text properties changes happen as usual but the changes are not treated as
modifications to the buffer."
  (declare (indent 0) (debug t))
  (let ((modified (make-symbol "modified")))
    `(let ((,modified (buffer-modified-p))
           (inhibit-read-only t)
           (inhibit-modification-hooks t)
           (buffer-undo-list t)
           (deactivate-mark nil)
           ;; Apparently these avoid file locking problems.
           (buffer-file-name nil)
           (buffer-file-truename nil))
       (unwind-protect
           (progn ,@body)
         (unless ,modified
           (restore-buffer-modified-p nil))))))

(provide 'dsp-mode)

;;; dsp-mode.el ends here
